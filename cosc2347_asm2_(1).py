# -*- coding: utf-8 -*-
"""COSC2347_ASM2 (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UNMJdz-OYk1mziAO3Q4WSGTISwaVYzxt

# Assignment 2
Each of the following exercises has 5 test cases. Each test case is worth 5 points. Note also that the TA has the right not to give or discount the grade even if the test cases are correct, but the implementation themselves are incorrect (e.g., one may fix the outputs to pass the test cases).

## Excercise 1
There is a multilevel marketing organization. In this organization, to assure quality, one person can have only one direct subordinate. Each person can get 20% out of his/her sales and 10% of his/her direct subordinate's income (note: the income, not the sale). Giving an input as an array of all the sales, please calculate the income for any given person. Assuming that the first one in the list doesn't have a subordinate and goes from left to right, the current person is the subordinate of the next one. Also, it is safe to assume that the company has at least one employee.

For instance, if the input is given as sales = [100, 200, 300]. Then:
- There are three people in this organization
- The first one (at index 0) doesn't have a subordinate
- The first one (at index 0) is the subordinate of the second one (at index 1)
- The second one (at index 1) is the subordinate of the third one (at index 2)


Please implement this using recursion by replacing <code>#CODE_HERE</code> placeholders.

Here is the pseudo-code:
- If i = 0 (base case) then return 20% of his/her sale only
- Else return 20% of his/her sale + 10% of his/her subordinate's income (thus need to call to income calculation here recursively)
"""

def calculate_income(a, i):
  #CODE_HERE

# test 1
a = [100]
calculate_income(a, 0)

# test 2
a = [100, 200]
calculate_income(a, 1)

# test 3
a = [100, 200, 300]
calculate_income(a, 0)

# test 4
a = [100, 200, 300]
calculate_income(a, 1)

# test 5
a = [100, 200, 300]
calculate_income(a, 2)

"""## Exercise 2
We can implement this problem using the memoization approach. Please replace the <code>#CODE_HERE</code> place holder to complete this.

Hint: The code logic for <code>#CODE_HERE</code> is similar to the pseudo-code listed above. However, instead of returning, we will assign it to a variable called <code>ret</code> then assign <code>ret</code> to <code>mem[i]</code> and return <code>mem[i]</code>.
"""

def calculate_income_mem(a, i, mem):
  if i not in mem:
    #CODE_HERE
    mem[i] = ret

  return mem[i]

# test 1
a = [100]
calculate_income_mem(a, 0, {})

# test 2
a = [100, 200]
calculate_income_mem(a, 1, {})

# test 3
a = [100, 200, 300]
calculate_income_mem(a, 0, {})

# test 4
a = [100, 200, 300]
calculate_income_mem(a, 1, {})

# test 5
a = [100, 200, 300]
calculate_income_mem(a, 2, {})

"""## Checkout the time complexity of these two approaches"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# a = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200]
# calculate_income(a, 11)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# a = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200]
# calculate_income_mem(a, 11, {})

"""## Reflection
This part is not graded but is helpful for your knowledge.
Which approach is faster and why?

## Exercise 3
Now, the company has changed its income calculation rule to encourage recruiting more subordinates. Specifically, the income of one person will be 20% of his/her own sale plus 10% of the income of his/her direct subordinate (if there is) and 5% of the subordinate of his/her subordinate (sub-subordinate, if there is). Please implement this using recursion.
"""

def calculate_income_new(a, i):
  if i == 0:
    #CODE_HERE
  elif i == 1:
    #CODE_HERE
  else:
    #CODE_HERE

# test 1
a = [100]
calculate_income_new(a, 0)

# test 2
a = [100, 200]
calculate_income_new(a, 1)

# test 3
a = [100, 200, 300]
calculate_income_new(a, 0)

# test 4
a = [100, 200, 300]
calculate_income_new(a, 1)

# test 5
a = [100, 200, 300]
calculate_income_new(a, 2)

"""## Exercise 4
Please implement the modified business rule using the memoization approach. Please replace the <code>#CODE_HERE</code> placeholders to complete this implementation.
"""

def calculate_income_new_mem(a, i, mem):
  if i not in mem:
    #CODE_HERE
  return mem[i]

# test 1
a = [100]
calculate_income_new_mem(a, 0, {})

# test 2
a = [100, 200]
calculate_income_new_mem(a, 1, {})

# test 3
a = [100, 200, 300]
calculate_income_new_mem(a, 0, {})

# test 4
a = [100, 200, 300]
calculate_income_new_mem(a, 1, {})

# test 5
a = [100, 200, 300]
calculate_income_new_mem(a, 2, {})

"""## Checkout the time complexity of these two approaches"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# a = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200]
# calculate_income_new(a, 11)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# a = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200]
# calculate_income_new_mem(a, 11, {})

"""## Reflection
This part is not graded but is helpful for your knowledge.
Which approach is faster and why?

# Bonus
This bonus section is worth 10 points, but the total/final grade should not exceed 100.

The implementation of the new business rule with memoization (<code>calculate_income_new_mem</code>) has good performance (in terms of time complexity). However, it still requires memory (suffers from memory/space complexity). Please revise this method using an iterative approach so it can still have good performance while not suffering from space requirements.
"""

