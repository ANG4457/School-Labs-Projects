# -*- coding: utf-8 -*-
"""COSC2347_ASM4 (2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HXxOSdh8IsM-3qyweJ9fu5Fc9C4DrsKG

# Exercise 1
Given a list of numbers, given a target, find two indices where values at these two locations add up to the given target. To avoid having to check trivial cases, it is safe to assume that there is one and exactly one result per given list and we can reuse the same value twice.

**Example:**<br/>
a = [1, 2, 3, 4, 5], target = 8 should return [2, 4]<br/>
a = [1, 2], target = 3 should return [0, 1]<br/>
a = [1, 19, 20, 22, 77, 15, 24, 15, 14], target = 33 should [1, 8]<br/>
"""

def find_indices(a, t):
  '''
  Given a list of integers, find two indices where values at that locations add up to a target.
  Input:
    a: list of integers
    t: the target (integer)
  Return:
    two indices that values at those locations add up to t
  '''
  # 1. for each index i1 in the range of list length
  # 1.1. take its value e1
  # 1.2. for each index i2 in the range of list length
  # 1.2.1 take its value e2
  # 1.2.2 if e1 + e2 == t return [i1, i2]
  for i1 in range(len(a)):
      e1 = a[i1]
      for i2 in range(len(a)):
          e2 = a[i2]
          if e1 + e2 == t:
              return [i1, i2]

# A function to perform test cases
def test(func, a, t, r, verbose=True):
  try:
    assert func(a, t) == r
    if verbose:
      print("Passed")
  except:
    if verbose:
      print("Failed")

# Test case 1 (5 points)
test(find_indices, [1, 2, 3, 4, 5], 9, [3, 4])

# Test case 2 (5 points)
test(find_indices, [1, 2], 3, [0, 1])

# Test case 3 (5 points)
test(find_indices, [1, 19, 20, 22, 77, 15, 24, 15, 14], 33, [1, 8])

# Test case 4 (5 points)
a = [x for x in range(10000)]
t = 9998 + 9999
r = [9998, 9999]
test(find_indices, a, t, r)

"""## "Wall clock" counting for Exercise 1
You can use these two code cells to have a sense (just a sense of) how the time changes compare to the input change
"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # Test case 5 (5 points)
# a = [x for x in range(100)]
# t = 98 + 99
# r = [98, 99]
# test(find_indices, a, t, r, False)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # Test case 6 (5 points)
# a = [x for x in range(1000)]
# t = 998 + 999
# r = [998, 999]
# test(find_indices, a, t, r, False)

"""## Reflection on Exercise 1
Please answers the following questions (by typing the answer) in the following code cell.
- from 100 values to 1000, what is the rate (ratio, order of growth) of input size change?
- from your execution, what is the rate (ratio, order of groth) of the execution time. Instruction: Take the time displayed, convert to the same unit, do the division and print the rate.


What is the time complexity O(?) of this implementation. Please print your answer as either one of the following
- "constant" (if it is O(1))
- "logarithmic" (if it is O(logn))
- "linear" (if it is O(n))
- "log linear" if it is O(nlogn)
- "quadratic" if it is O(n^2)
- "exponential" if it is O(2^n)
"""

# print the rate of input change (5 points)
# print the rate of time change (5 points)
# print the Big O (10 points)
# CODE_HERE
import time

def linear_search(arr, target):
    for i, num in enumerate(arr):
        if num == target:
            return i
    return -1

# Generate a list with values from 1 to n
n = 100
arr = list(range(1, n + 1))

# Perform a linear search
target = 50
start_time = time.time()
result = linear_search(arr, target)
end_time = time.time()

print(f"Input size: {n}")
print(f"Execution time: {end_time - start_time} seconds")

if result != -1:
    print(f"Target found at index {result}")
else:
    print("Target not found")

"""# Exercise 2
Same case as in Exercise 1, however, a dictionary to store values to find after passing each element (trade-off between memory and time).

Please follow the comments and specifications to code this approach.
"""

def find_indices_dict(a, t):
  '''
  Given a list of integers, find two indices where values at that locations add up to a target.
  Input:
    a: list of integers
    t: the target (integer)
  Return:
    two indices that values at those locations add up to t
  '''
  # 1. create an empty dictionary called to_find
  # 2. for each index i in the range of the length of the list a
  # 2.1. get the element value
  # 2.2. add a key as the value to be found that when add with this current value e makes the target (i.e., t = e + key, so key = t - e) and the value is this current index (Hint: to_find[t-e] = i)
  #      Note: adding the key here assures that the element can add with itself (which is allowable from the exercise assumption)
  # 2.3. check if that element is in the dictionary (to_find)
  # 2.3.1 If yes, return the array with value of to_find with key e and the current index (Hint: [to_find[e], i])
  # This algorithm will surely return one result (because the assumption is to have one value)
  # CODE_HERE

  to_find = {}  # 1. create an empty dictionary called to_find
  for i in range(len(a)):  # 2. for each index i in the range of the length of the list a
        e = a[i]  # 2.1. get the element value
        key = t - e  # 2.2. calculate the key as (target - current value)
        to_find[key] = i  # 2.2. add a key to the dictionary
        if e in to_find:  # 2.3. check if that element is in the dictionary (to_find)
            return [to_find[e], i]  # 2.3.1 If yes, return the array with indices

# Example usage:
a = [2, 7, 11, 15]
t = 9
result = find_indices_dict(a, t)
print(result)  # Should print [0, 1]

# Test case 1 (5 points)
test(find_indices_dict, [1, 2, 3, 4, 5], 9, [3, 4])

# Test case 2 (3 points)
test(find_indices_dict, [1, 2], 3, [0, 1])

# Test case 3 (5 points)
test(find_indices_dict, [1, 19, 20, 22, 77, 15, 24, 15, 14], 33, [1, 8])

# Test case 4 (5 points)
a = [x for x in range(10000)]
t = 9998 + 9999
r = [9998, 9999]
test(find_indices_dict, a, t, r)

"""# "Wall clock" counting for Exercise 2
You can use these two code cells to have a sense (just a sense of) how the time changes compare to the input change
"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # test case 5 (5 points)
# a = [x for x in range(100)]
# t = 98 + 99
# r = [98, 99]
# test(find_indices_dict, a, t, r, False)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # test case 6 (5 points)
# a = [x for x in range(1000)]
# t = 998 + 999
# r = [998, 999]
# test(find_indices_dict, a, t, r, False)

"""## Reflection on Exercise 2
Please answers the following questions (by typing the answer) in the following code cell.
- from 100 values to 1000, what is the rate (ratio, order of growth) of input size change?
- from your execution, what is the rate (ratio, order of groth) of the execution time. Instruction: Take the time displayed, convert to the same unit, do the division and print the rate.


What is the time complexity O(?) of this implementation. Please print your answer as either one of the following
- "constant" (if it is O(1))
- "logarithmic" (if it is O(logn))
- "linear" (if it is O(n))
- "log linear" if it is O(nlogn)
- "quadratic" if it is O(n^2)
- "exponential" if it is O(2^n)
"""

# print the rate of input change (5 points)
# print the rate of time change (5 points)
# print the Big O (10 points)
# CODE_HERE
import time

def find_indices_dict(a, t):
    '''
    Given a list of integers, find two indices where values at those locations add up to a target.
    Input:
      a: list of integers
      t: the target (integer)
    Return:
      two indices that values at those locations add up to t
    '''
    to_find = {}  # 1. create an empty dictionary called to_find
    for i in range(len(a)):  # 2. for each index i in the range of the length of the list a
        e = a[i]  # 2.1. get the element value
        key = t - e  # 2.2. calculate the key as (target - current value)
        to_find[key] = i  # 2.2. add a key to the dictionary
        if e in to_find:  # 2.3. check if that element is in the dictionary (to_find)
            return [to_find[e], i]  # 2.3.1 If yes, return the array with indices

# Calculate the rate of input change
input_size_1 = 100
input_size_2 = 1000
rate_of_input_change = input_size_2 / input_size_1
print(f"Rate of input change: {rate_of_input_change}")

# Measure the execution time for n=100
a_100 = list(range(1, input_size_1 + 1))
t = 50  # Target
start_time_100 = time.time()
result_100 = find_indices_dict(a_100, t)
end_time_100 = time.time()

# Measure the execution time for n=1000
a_1000 = list(range(1, input_size_2 + 1))
start_time_1000 = time.time()
result_1000 = find_indices_dict(a_1000, t)
end_time_1000 = time.time()

# Calculate the rate of time change
rate_of_time_change = (end_time_1000 - start_time_1000) / (end_time_100 - start_time_100)
print(f"Rate of time change: {rate_of_time_change}")

# Determine the Big O notation
big_o = "linear"  # The time complexity is O(n)
print(f"Big O Notation: {big_o}")